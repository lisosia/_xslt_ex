<HTML>
<style>
	body {background-color:lightgrey;}
	h1   {color:blue;}
	div  { margin-left: 40px; }
      </style>
<BODY>
<h1>Table of Contents</h1>
<a id="dt-xml-proc">1.
      XML Processor . dt-xml-proc<br>A software module called
an XML processor is used to read XML documents and provide access
to their content and structure.<BR> --- <br></a><a id="dt-app">2.
      Application . dt-app<br>It
is assumed that an XML processor is doing its work on behalf of another module,
called the application.<BR> --- <br></a><a id="dt-error">3.
      Error . dt-error<br>A violation of the rules of this specification;
results are undefined. Unless otherwise specified, failure to observe a prescription of this specification indicated by one of the keywords MUST, REQUIRED, MUST NOT, SHALL and SHALL NOT is an error.  Conforming software MAY detect and report an error
and MAY recover from it.<BR> --- <br></a><a id="dt-fatal">4.
      Fatal Error . dt-fatal<br>An error which a conforming XML processor
										MUST detect and report to the application.
After encountering a fatal error, the processor MAY continue processing the
data to search for further errors and MAY report such errors to the application.
In order to support correction of errors, the processor MAY make unprocessed
data from the document (with intermingled character data and markup) available
to the application. Once a fatal error is detected, however, the processor
MUST NOT continue normal processing (i.e., it MUST NOT continue to pass character
data and information about the document's logical structure to the application
in the normal way).<BR> --- <br></a><a id="dt-atuseroption">5.
      At user option . dt-atuseroption<br>Conforming software
MAY or MUST (depending on the modal verb in the sentence) behave as described;
if it does, it MUST provide users a means to enable or disable the behavior
described.<BR> --- <br></a><a id="dt-vc">6.
      Validity constraint . dt-vc<br>A rule which applies to
all valid XML documents. Violations of validity
constraints are errors; they MUST, at user option, be reported by validating XML processors.<BR> --- <br></a><a id="dt-wfc">7.
      Well-formedness constraint . dt-wfc<br>A rule which applies
to all well-formed XML documents. Violations
of well-formedness constraints are fatal errors.<BR> --- <br></a><a id="dt-match">8.
      match . dt-match<br>(Of strings or names:) Two strings
or names being compared are identical. Characters with multiple possible
representations in ISO/IEC 10646 (e.g. characters with both precomposed and
base+diacritic forms) match only if they have the same representation in both
strings. No
case folding is performed. (Of strings and rules in the grammar:) A string
matches a grammatical production if it belongs to the language generated by
that production. (Of content and content models:) An element matches its declaration
when it conforms in the fashion described in the constraint .<BR> --- <br></a><a id="dt-compat">9.
      For Compatibility . dt-compat<br>Marks
a sentence describing a feature of XML included solely to ensure
that XML remains compatible with SGML.<BR> --- <br></a><a id="dt-interop">10.
      For interoperability . dt-interop<br>Marks
a sentence describing a non-binding recommendation included to increase
the chances that XML documents can be processed by the existing installed
base of SGML processors which predate the WebSGML Adaptations Annex to ISO 8879.<BR> --- <br></a><a id="dt-xml-doc">11.
      XML Document . dt-xml-doc<br> A data object is an XML
document if it is well-formed,
as defined in this specification. In addition, the XML document is
valid if it meets certain further constraints.<BR> --- <br></a><a id="dt-wellformed">12.
      Well-Formed . dt-wellformed<br> A textual object is a well-formed
XML document if:<BR> --- <br></a><a id="dt-root">13.
      Root Element . dt-root<br>There is exactly one element,
called the root, or document element, no part of which appears
in the content of any other element.<BR> --- <br></a><a id="dt-parentchild">14.
      Parent/Child . dt-parentchild<br>As a consequence of this,
for each non-root element C in the document, there is one other element P
in the document such that C is in the content of P, but
is not in the content of any other element that is in the content of P. P
is referred to as the parent of C, and C as
a child of P.<BR> --- <br></a><a id="dt-text">15.
      Text . dt-text<br>A parsed entity contains text,
a sequence of characters, which may
represent markup or character data.<BR> --- <br></a><a id="dt-character">16.
      Character . dt-character<br>A character
is an atomic unit of text as specified by ISO/IEC 10646:2000 . Legal characters are tab, carriage
return, line feed, and the legal characters
of Unicode and ISO/IEC 10646. The
versions of these standards cited in  were
current at the time this document was prepared. New characters may be added
to these standards by amendments or new editions. Consequently, XML processors
MUST accept any character in the range specified for Char.
<BR> --- <br></a><a id="dt-name-x">17.
      Name . dt-name-x<br>A Name is a token beginning
with a letter or one of a few punctuation characters, and continuing with
letters, digits, hyphens, underscores, colons, or full stops, together known
as name characters.<BR> --- <br></a><a id="dt-name">18.
      Name . dt-name<br>A Name is an Nmtoken with a restricted set of initial characters.<BR> --- <br></a><a id="dt-markup">19.
      Markup . dt-markup<br>
						Markup takes the form of start-tags, end-tags, empty-element tags, entity references, character
references, comments, CDATA section delimiters, document
type declarations, processing instructions, XML declarations, text declarations,
and any white space that is at the top level of the document entity (that
is, outside the document element and not inside any other markup).<BR> --- <br></a><a id="dt-chardata">20.
      Character Data . dt-chardata<br>All text that is not markup
constitutes the character data of the document.<BR> --- <br></a><a id="dt-comment">21.
      Comment . dt-comment<br>
						Comments may appear
anywhere in a document outside other markup;
in addition, they may appear within the document type declaration at places
allowed by the grammar. They are not part of the document's character
data; an XML processor MAY, but need not, make it possible for an
application to retrieve the text of comments. For
compatibility, the string 
							--
						 (double-hyphen)
MUST NOT occur within comments.<BR> --- <br></a><a id="dt-pi">22.
      Processing instruction . dt-pi<br>
						Processing instructions
(PIs) allow documents to contain instructions for applications.<BR> --- <br></a><a id="dt-cdsection">23.
      CDATA Section . dt-cdsection<br>
						CDATA sections may occur anywhere character data may occur; they are used to escape blocks
of text containing characters which would otherwise be recognized as markup.
CDATA sections begin with the string 
							&lt;![CDATA[
						
and end with the string 
							]]&gt;
						:<BR> --- <br></a><a id="dt-xmldecl">24.
      XML Declaration . dt-xmldecl<br>XML documents SHOULD
begin with an XML declaration which specifies the version of
XML being used.<BR> --- <br></a><a id="dt-valid">25.
      Validity . dt-valid<br>An XML document is valid if it has an associated
document type declaration and if the document complies with the constraints
expressed in it.<BR> --- <br></a><a id="dt-doctype">26.
      Document Type Declaration . dt-doctype<br>The XML document
type declaration contains or points to markup
declarations that provide a grammar for a class of documents. This
grammar is known as a document type definition, or DTD. The document
type declaration can point to an external subset (a special kind of external entity) containing markup declarations,
or can contain the markup declarations directly in an internal subset, or
can do both. The DTD for a document consists of both subsets taken together.<BR> --- <br></a><a id="dt-markupdecl">27.
      markup declaration . dt-markupdecl<br> A markup declaration
is an element type declaration, an attribute-list declaration, an entity
declaration, or a notation declaration.<BR> --- <br></a><a id="dt-extmkpdecl">28.
      External Markup Declaration . dt-extmkpdecl<br>An external
markup declaration is defined as a markup declaration occurring in
the external subset or in a parameter entity (external or internal, the latter
being included because non-validating processors are not required to read
them).<BR> --- <br></a><a id="dt-element">29.
      Element . dt-element<br>Each XML
document contains one or more elements, the boundaries
of which are either delimited by start-tags
and end-tags, or, for empty
elements, by an empty-element tag. Each
element has a type, identified by name, sometimes called its generic
identifier (GI), and may have a set of attribute specifications.<BR> --- <br></a><a id="dt-stag">30.
      Start-Tag . dt-stag<br>The beginning of every non-empty
XML element is marked by a start-tag.<BR> --- <br></a><a id="dt-attr">31.
      Attribute . dt-attr<br> The Name-AttValue
pairs are referred to as the attribute specifications of the
element<BR> --- <br></a><a id="dt-attrname">32.
      Attribute Name . dt-attrname<br>with the Name in each pair referred to as the attribute name
					<BR> --- <br></a><a id="dt-attrval">33.
      Attribute Value . dt-attrval<br>the content of the AttValue (the text between the ' or "
delimiters) as the attribute value.<BR> --- <br></a><a id="dt-etag">34.
      End Tag . dt-etag<br>The end of every element that begins
with a start-tag MUST be marked by an end-tag containing a name
that echoes the element's type as given in the start-tag:<BR> --- <br></a><a id="dt-content">35.
      Content . dt-content<br>The text
between the start-tag and end-tag is called the element's content:<BR> --- <br></a><a id="dt-empty">36.
      Empty . dt-empty<br>An element
with no content is said to be empty.<BR> --- <br></a><a id="dt-eetag">37.
      empty-element tag . dt-eetag<br>An empty-element
tag takes a special form:<BR> --- <br></a><a id="dt-eldecl">38.
      Element Type declaration . dt-eldecl<br>An element
type declaration takes the form:<BR> --- <br></a><a id="dt-elemcontent">39.
      Element content . dt-elemcontent<br>An element type has element content when elements
of that type MUST contain only child
elements (no character data), optionally separated by white space (characters
matching the nonterminal S).<BR> --- <br></a><a id="dt-content-model">40.
      Content model . dt-content-model<br>In this case, the constraint includes a content
model, a simple grammar governing the allowed types of the
child elements and the order in which they are allowed to appear.<BR> --- <br></a><a id="dt-mixed">41.
      Mixed Content . dt-mixed<br>An element type
has mixed content when elements of that type may contain character
data, optionally interspersed with child
elements.<BR> --- <br></a><a id="dt-attdecl">42.
      Attribute-List Declaration . dt-attdecl<br>
						Attribute-list
declarations specify the name, data type, and default value (if any)
of each attribute associated with a given element type:<BR> --- <br></a><a id="dt-enumerated">43.
      Enumerated Attribute Values . dt-enumerated<br>
							Enumerated attributes
							have a list of allowed values in their declaration
						<BR> --- <br></a><a id="dt-default">44.
      Attribute Default . dt-default<br>If
the declaration is neither #REQUIRED nor #IMPLIED, then
the AttValue value contains the declared default
value; the #FIXED keyword states that the attribute MUST always have
the default value.
When an XML processor encounters
an element
without a specification for an attribute for which it has read a default
value declaration, it MUST report the attribute with the declared default
value to the application.<BR> --- <br></a><a id="dt-cond-section">45.
      conditional section . dt-cond-section<br>
						Conditional
sections are portions of the document type
declaration external subset or
of external parameter entities which are included in, or excluded from,
the logical structure of the DTD based on the keyword which governs them.<BR> --- <br></a><a id="dt-entity">46.
      Entity . dt-entity<br>An XML document may consist of one
or many storage units. These
are called entities; they all have content and are
all (except for the document entity and
the external DTD subset) identified by
entity name.<BR> --- <br></a><a id="dt-parsedent">47.
      Text Entity . dt-parsedent<br>The contents of a parsed
entity are referred to as its replacement
text; this text is considered an
integral part of the document.<BR> --- <br></a><a id="dt-unparsed">48.
      Unparsed Entity . dt-unparsed<br>An unparsed entity
is a resource whose contents may or may not be text,
and if text, may
be other than XML. Each unparsed entity has an associated notation, identified by name. Beyond a requirement
that an XML processor make the identifiers for the entity and notation available
to the application, XML places no constraints on the contents of unparsed
entities.<BR> --- <br></a><a id="gen-entity">49.
      general entity . gen-entity<br>
					General entities
are entities for use within the document content. In this specification, general
entities are sometimes referred to with the unqualified term entity
when this leads to no ambiguity.<BR> --- <br></a><a id="dt-PE">50.
      Parameter entity . dt-PE<br>
					Parameter
entities are parsed entities for use within the DTD.<BR> --- <br></a><a id="dt-charref">51.
      Character Reference . dt-charref<br> A character
reference refers to a specific character in the ISO/IEC 10646 character
set, for example one not directly accessible from available input devices.<BR> --- <br></a><a id="dt-entref">52.
      Entity Reference . dt-entref<br>An entity reference
refers to the content of a named entity.<BR> --- <br></a><a id="dt-GERef">53.
      General Entity Reference . dt-GERef<br>References to parsed general entities use
ampersand (&amp;) and semicolon (;) as delimiters.<BR> --- <br></a><a id="dt-PERef">54.
      Parameter-entity reference . dt-PERef<br>
						Parameter-entity references
use percent-sign (%) and semicolon (;) as delimiters.<BR> --- <br></a><a id="dt-entdecl">55.
      entity declaration . dt-entdecl<br> Entities are declared
thus:<BR> --- <br></a><a id="dt-internent">56.
      Internal Entity Replacement Text . dt-internent<br>If the
entity definition is an EntityValue, the defined
entity is called an internal entity. There is no separate physical
storage object, and the content of the entity is given in the declaration.<BR> --- <br></a><a id="dt-extent">57.
      External Entity . dt-extent<br>If the entity is not internal,
it is an external entity, declared as follows:<BR> --- <br></a><a id="dt-sysid">58.
      System Identifier . dt-sysid<br>The SystemLiteral is called the entity's system
identifier. It is meant to be converted to a URI reference
(as defined in ),
as part of the
process of dereferencing it to obtain input for the XML processor to construct the
entity's replacement text.<BR> --- <br></a><a id="dt-pubid">59.
      Public identifier . dt-pubid<br> In addition to a system
identifier, an external identifier may include a public identifier.<BR> --- <br></a><a id="dt-include">60.
      Include . dt-include<br>An entity is included
when its replacement text is retrieved
and processed, in place of the reference itself, as though it were part of
the document at the location the reference was recognized.<BR> --- <br></a><a id="dt-litentval">61.
      Literal Entity Value . dt-litentval<br>For an
internal entity, the literal
entity value is the quoted string actually present in the entity declaration,
corresponding to the non-terminal EntityValue.<BR> --- <br></a><a id="dt-extlitentval">62.
      Literal Entity Value . dt-extlitentval<br>For an external entity, the literal
entity value is the exact text contained in the entity.<BR> --- <br></a><a id="dt-repltext">63.
      Replacement Text . dt-repltext<br>For an
internal entity, the replacement text
is the content of the entity, after replacement of character references and
parameter-entity references.<BR> --- <br></a><a id="dt-extrepltext">64.
      Replacement Text . dt-extrepltext<br>For
an external entity, the replacement text is the content of the entity,
after stripping the text declaration (leaving any surrounding whitespace) if there
is one but without any replacement of character references or parameter-entity
references.<BR> --- <br></a><a id="dt-escape">65.
      escape . dt-escape<br>Entity and character references may
both be used to escape the left angle bracket, ampersand, and
other delimiters. A set of general entities (amp,
lt,
gt,
apos,
quot) is specified for
this purpose. Numeric character references may also be used; they are expanded
immediately when recognized and MUST be treated as character data, so the
numeric character references 
							&amp;#60;
						 and 
							&amp;#38;
						 may be used to escape &lt; and &amp; when they occur
in character data.<BR> --- <br></a><a id="dt-notation">66.
      Notation . dt-notation<br>
						Notations identify
by name the format of unparsed entities,
the format of elements which bear a notation attribute, or the application
to which a processing instruction is addressed.<BR> --- <br></a><a id="dt-notdecl">67.
      Notation Declaration . dt-notdecl<br>
						Notation declarations
provide a name for the notation, for use in entity and attribute-list declarations
and in attribute specifications, and an external identifier for the notation
which may allow an XML processor or its client application to locate a helper
application capable of processing data in the given notation.<BR> --- <br></a><a id="dt-docent">68.
      Document Entity . dt-docent<br>The document entity
serves as the root of the entity tree and a starting-point for an XML processor.<BR> --- <br></a><a id="dt-validating">69.
      Validating Processor . dt-validating<br>
						Validating
processors
						MUST,
at user option, report violations of the constraints expressed by
the declarations in the DTD, and failures
to fulfill the validity constraints given in this specification.<BR> --- <br></a><a id="dt-use-mdecl">70.
      Process Declarations . dt-use-mdecl<br> While they are not required
to check the document for validity, they are REQUIRED to process
all the declarations they read in the internal DTD subset and in any parameter
entity that they read, up to the first reference to a parameter entity that
they do not read; that is to say, they MUST use the information
in those declarations to normalize
attribute values, include the replacement
text of internal entities, and supply default
attribute values.<BR> --- <br></a><h1>where terms used</h1>
<a href="#dt-xml-doc">dt-xml-doc<br></a>Extensible Markup Language, abbreviated XML, describes a class of data
objects called <strong><termref def="dt-xml-doc">XML documents</termref></strong> and partially
describes the behavior of computer programs which process them. XML is an
application profile or restricted form of SGML, the Standard Generalized Markup
Language . By construction, XML documents are conforming
SGML documents.<br><br><a href="#dt-entity">dt-entity<br></a>XML documents are made up of storage units called <strong><termref def="dt-entity">entities</termref></strong>,
which contain either parsed or unparsed data. Parsed data is made up of <strong><termref def="dt-character">characters</termref></strong>, some of which form <strong><termref def="dt-chardata">character
data</termref></strong>, and some of which form <strong><termref def="dt-markup">markup</termref></strong>.
Markup encodes a description of the document's storage layout and logical
structure. XML provides a mechanism to impose constraints on the storage layout
and logical structure.<br><br><a href="#dt-entity">dt-entity<br></a>Each XML document has both a logical and a physical structure. Physically,
the document is composed of units called <strong><termref def="dt-entity">entities</termref></strong>.
An entity may
				<strong><termref def="dt-entref">refer</termref></strong> to other entities to
cause their inclusion in the document. A document begins in a root
or <strong><termref def="dt-docent">document entity</termref></strong>. Logically, the document
is composed of declarations, elements, comments, character references, and
processing instructions, all of which are indicated in the document by explicit
markup. The logical and physical structures MUST nest properly, as described
in .<br><br><a href="#dt-parsedent">dt-parsedent<br></a>Each of the <strong><termref def="dt-parsedent">parsed entities</termref></strong>
which is referenced directly or indirectly within the document is <strong><termref def="dt-wellformed">well-formed</termref></strong>.<br><br><a href="#dt-element">dt-element<br></a>It contains one or more <strong><termref def="dt-element">elements</termref></strong>.<br><br><a href="#dt-stag">dt-stag<br></a>
							There is exactly one element,
called the root, or document element, no part of which appears
in the <strong><termref def="dt-content">content</termref></strong> of any other element. For
all other elements, if the <strong><termref def="dt-stag">start-tag</termref></strong> is in
the content of another element, the <strong><termref def="dt-etag">end-tag</termref></strong>
is in the content of the same element. More simply stated, the elements,
delimited by start- and end-tags, nest properly within each other.<br><br><a href="#dt-text">dt-text<br></a>
					<strong><termref def="dt-text">Text</termref></strong> consists of intermingled <strong><termref def="dt-chardata">character data</termref></strong> and markup. 
						Markup takes the form of <strong><termref def="dt-stag">start-tags</termref></strong>, <strong><termref def="dt-etag">end-tags</termref></strong>, <strong><termref def="dt-empty">empty-element tags</termref></strong>, <strong><termref def="dt-entref">entity references</termref></strong>, <strong><termref def="dt-charref">character
references</termref></strong>, <strong><termref def="dt-comment">comments</termref></strong>, <strong><termref def="dt-cdsection">CDATA section</termref></strong> delimiters, <strong><termref def="dt-doctype">document
type declarations</termref></strong>, <strong><termref def="dt-pi">processing instructions</termref></strong>, XML declarations, text declarations,
and any white space that is at the top level of the document entity (that
is, outside the document element and not inside any other markup).
				<br><br><a href="#dt-comment">dt-comment<br></a>The ampersand character (&amp;) and the left angle bracket (&lt;) MUST NOT appear
in their literal form, except when used as markup delimiters, or
within a <strong><termref def="dt-comment">comment</termref></strong>, a <strong><termref def="dt-pi">processing
instruction</termref></strong>, or a <strong><termref def="dt-cdsection">CDATA section</termref></strong>.

If they are needed elsewhere, they MUST be <strong><termref def="dt-escape">escaped</termref></strong>
using either <strong><termref def="dt-charref">numeric character references</termref></strong>
or the strings 
						&amp;amp;
					 and 
						&amp;lt;
					
respectively. The right angle bracket (&gt;) may be represented using the string 
						&amp;gt;
					,
and MUST, <strong><termref def="dt-compat">for compatibility</termref></strong>, be escaped
using either 
						&amp;gt;
					 or a character reference when it
appears in the string 
						]]&gt;
					 in content, when
that string is not marking the end of a <strong><termref def="dt-cdsection">CDATA
section</termref></strong>.<br><br><a href="#dt-chardata">dt-chardata<br></a>PIs are not part of the document's <strong><termref def="dt-chardata">character
data</termref></strong>, but MUST be passed through to the application. The PI begins
with a target (PITarget) used to identify the application
to which the instruction is directed. The target names 
						XML
					, 
						xml
					,
and so on are reserved for standardization in this or future versions of this
specification. The XML <strong><termref def="dt-notation">Notation</termref></strong> mechanism
may be used for formal declaration of PI targets. Parameter
entity references MUST NOT be recognized within processing instructions.<br><br><a href="#dt-chardata">dt-chardata<br></a>An example of a CDATA section, in which 
						&lt;greeting&gt;
					
and 
						&lt;/greeting&gt;
					 are recognized as <strong><termref def="dt-chardata">character data</termref></strong>, not <strong><termref def="dt-markup">markup</termref></strong>:<br><br><a href="#dt-wellformed">dt-wellformed<br></a>
					XML documents SHOULD
begin with an XML declaration which specifies the version of
XML being used. For example, the following is a complete XML document, <strong><termref def="dt-wellformed">well-formed</termref></strong> but not <strong><termref def="dt-valid">valid</termref></strong>:<br><br><a href="#dt-doctype">dt-doctype<br></a>The function of the markup in an XML document is to describe its storage and
logical structure and to associate attribute
name-value pairs with its logical structures. XML provides a mechanism, the
<strong><termref def="dt-doctype">document
type declaration</termref></strong>, to define constraints on the logical structure
and to support the use of predefined storage units. An XML document is valid if it has an associated
document type declaration and if the document complies with the constraints
expressed in it.
				<br><br><a href="#dt-element">dt-element<br></a>The document type declaration MUST appear before the first <strong><termref def="dt-element">element</termref></strong>
in the document.<br><br><a href="#dt-PE">dt-PE<br></a>
					 A markup declaration
is an <strong><termref def="dt-eldecl">element type declaration</termref></strong>, an <strong><termref def="dt-attdecl">attribute-list declaration</termref></strong>, an <strong><termref def="dt-entdecl">entity
declaration</termref></strong>, or a <strong><termref def="dt-notdecl">notation declaration</termref></strong>.
These declarations may be contained in whole or in part within <strong><termref def="dt-PE">parameter
entities</termref></strong>, as described in the well-formedness and validity constraints
below. For further
information, see .<br><br><a href="#dt-repltext">dt-repltext<br></a>The markup declarations may be made up in whole or in part of the <strong><termref def="dt-repltext">replacement text</termref></strong> of <strong><termref def="dt-PE">parameter
entities</termref></strong>. The productions later in this specification for individual
nonterminals (elementdecl, AttlistDecl,
and so on) describe the declarations after all the parameter
entities have been <strong><termref def="dt-include">included</termref></strong>.<br><br><a href="#dt-root">dt-root<br></a>The Name
in the document type declaration MUST match the element type of the <strong><termref def="dt-root">root element</termref></strong>.<br><br><a href="#dt-repltext">dt-repltext<br></a>Parameter-entity <strong><termref def="dt-repltext">replacement text</termref></strong>
						MUST be properly nested with markup declarations. That is to say, if either
the first character or the last character of a markup declaration (markupdecl
above) is contained in the replacement text for a <strong><termref def="dt-PERef">parameter-entity
reference</termref></strong>, both MUST be contained in the same replacement text.<br><br><a href="#dt-PERef">dt-PERef<br></a>In
the internal DTD subset, <strong><termref def="dt-PERef">parameter-entity references</termref></strong>
						MUST NOT occur within markup declarations; they may occur where markup declarations can occur.
(This does not apply to references that occur in external parameter entities
or to the external subset.)<br><br><a href="#dt-PERef">dt-PERef<br></a>Like the internal subset, the external subset and any external parameter
entities referenced
in a DeclSep
					MUST consist of a series of
complete markup declarations of the types allowed by the non-terminal symbol markupdecl, interspersed with white space or <strong><termref def="dt-PERef">parameter-entity references</termref></strong>. However, portions of
the contents of the external subset or of these
external parameter entities may conditionally be ignored by using the <strong><termref def="dt-cond-section">conditional section</termref></strong> construct; this is not
allowed in the internal subset but is
allowed in external parameter entities referenced in the internal subset.<br><br><a href="#dt-PERef">dt-PERef<br></a>The external subset and external parameter entities also differ from the
internal subset in that in them, <strong><termref def="dt-PERef">parameter-entity
references</termref></strong> are permitted within markup declarations,
not only between markup declarations.<br><br><a href="#dt-sysid">dt-sysid<br></a>The <strong><termref def="dt-sysid">system identifier</termref></strong>
					
						hello.dtd
					
gives the address (a URI reference) of a DTD for the document.<br><br><a href="#dt-xml-proc">dt-xml-proc<br></a>Markup declarations can affect the content of the document, as passed from
an <strong><termref def="dt-xml-proc">XML processor</termref></strong> to an application; examples
are attribute defaults and entity declarations. The standalone document declaration,
which may appear as a component of the XML declaration, signals whether or
not there are such declarations which appear external to the <strong><termref def="dt-docent">document
entity</termref></strong>
or in parameter entities. An external
markup declaration is defined as a markup declaration occurring in
the external subset or in a parameter entity (external or internal, the latter
being included because non-validating processors are not required to read
them).
				<br><br><a href="#dt-extmkpdecl">dt-extmkpdecl<br></a>In a standalone document declaration, the value yes indicates
that there are no <strong><termref def="dt-extmkpdecl">external markup declarations</termref></strong> which
affect the information passed from the XML processor to the application. The
value no indicates that there are or may be such external
markup declarations. Note that the standalone document declaration only denotes
the presence of external declarations; the presence, in a document,
of references to external entities, when those entities are internally
declared, does not change its standalone status.<br><br><a href="#dt-default">dt-default<br></a>attributes with <strong><termref def="dt-default">default</termref></strong> values,
if elements to which these attributes apply appear in the document without
specifications of values for these attributes, or<br><br><a href="#dt-entref">dt-entref<br></a>entities (other than amp,
lt,
gt,
apos,
quot), if <strong><termref def="dt-entref">references</termref></strong>
to those entities appear in the document, or<br><br><a href="#dt-elemcontent">dt-elemcontent<br></a>element types with <strong><termref def="dt-elemcontent">element content</termref></strong>,
if white space occurs directly within any instance of those types.<br><br><a href="#dt-xml-proc">dt-xml-proc<br></a>An <strong><termref def="dt-xml-proc">XML processor</termref></strong>
					MUST always pass
all characters in a document that are not markup through to the application.
A <strong><termref def="dt-validating"> validating XML processor</termref></strong>
					MUST also
inform the application which of these characters constitute white space appearing
in <strong><termref def="dt-elemcontent">element content</termref></strong>.<br><br><a href="#dt-attr">dt-attr<br></a>A special <strong><termref def="dt-attr">attribute</termref></strong> named xml:space may be attached to an element to signal an intention that in that element,
white space should be preserved by applications. In valid documents, this
attribute, like any other, MUST be <strong><termref def="dt-attdecl">declared</termref></strong>
if it is used. When declared, it MUST be given as an <strong><termref def="dt-enumerated">enumerated
type</termref></strong> whose values
are one or both of default and preserve.
For example:<br><br><a href="#dt-root">dt-root<br></a>The <strong><termref def="dt-root">root element</termref></strong> of any document is considered
to have signaled no intentions as regards application space handling, unless
it provides a value for this attribute or the attribute is declared with a
default value.<br><br><a href="#dt-parsedent">dt-parsedent<br></a>XML <strong><termref def="dt-parsedent">parsed entities</termref></strong> are often stored
in computer files which, for editing convenience, are organized into lines.
These lines are typically separated by some combination of the characters
CARRIAGE RETURN (#xD) and LINE FEED (#xA).<br><br><a href="#dt-app">dt-app<br></a>To
simplify the tasks of <strong><termref def="dt-app">applications</termref></strong>, the
<strong><termref def="dt-xml-proc">XML
processor</termref></strong>
					MUST behave as if it normalized all line breaks in external parsed
entities (including the document entity) on input, before parsing, by translating
both the two-character sequence #xD #xA and any #xD that is not followed by
#xA to a single #xA character.<br><br><a href="#dt-attr">dt-attr<br></a>In document processing, it is often useful to identify the natural or formal
language in which the content is written. A special <strong><termref def="dt-attr">attribute</termref></strong>
named xml:lang may be inserted in documents to specify the language
used in the contents and attribute values of any element in an XML document.
In valid documents, this attribute, like any other, MUST be <strong><termref def="dt-attdecl">declared</termref></strong>
if it is used. The
values of the attribute are language identifiers as defined by , Tags
for the Identification of Languages, or its successor; in addition, the empty string may be specified.<br><br><a href="#dt-attrname">dt-attrname<br></a>
				Each <strong><termref def="dt-xml-doc">XML
document</termref></strong> contains one or more elements, the boundaries
of which are either delimited by <strong><termref def="dt-stag">start-tags</termref></strong>
and <strong><termref def="dt-etag">end-tags</termref></strong>, or, for <strong><termref def="dt-empty">empty</termref></strong>
elements, by an <strong><termref def="dt-eetag">empty-element tag</termref></strong>. Each
element has a type, identified by name, sometimes called its generic
identifier (GI), and may have a set of attribute specifications.
Each attribute specification has a <strong><termref def="dt-attrname">name</termref></strong>
and a <strong><termref def="dt-attrval">value</termref></strong>.<br><br><a href="#dt-content">dt-content<br></a>The declaration matches EMPTY and the element has no <strong><termref def="dt-content">content</termref></strong> (not even entity
references, comments, PIs or white space).<br><br><a href="#dt-parentchild">dt-parentchild<br></a>The declaration matches children and the
sequence of <strong><termref def="dt-parentchild">child elements</termref></strong> belongs
to the language generated by the regular expression in the content model,
with optional white space, comments and
PIs (i.e. markup matching production [27] Misc) between the
start-tag and the first child element, between child elements, or between
the last child element and the end-tag. Note that a CDATA section containing
only white space or a reference
to an entity whose replacement text is character references expanding to white
space do not
match the nonterminal S, and
hence cannot appear in these positions; however, a
reference to an internal entity with a literal value consisting of character
references expanding to white space does match S, since its
replacement text is the white space resulting from expansion of the character
references.<br><br><a href="#dt-chardata">dt-chardata<br></a>The declaration matches Mixed, and the content
(after replacing
any entity references with their replacement text) consists of
<strong><termref def="dt-chardata">character data</termref></strong>
(including <strong><termref def="dt-cdsection">CDATA sections</termref></strong>),
<strong><termref def="dt-comment">comments</termref></strong>, <strong><termref def="dt-pi">PIs</termref></strong> and <strong><termref def="dt-parentchild">child elements</termref></strong> whose types match names in the
content model.<br><br><a href="#dt-cdsection">dt-cdsection<br></a>The declaration matches ANY, and the content (after replacing
any entity references with their replacement text)
consists of character data, <strong><termref def="dt-cdsection">CDATA
sections</termref></strong>, <strong><termref def="dt-comment">comments</termref></strong>, <strong><termref def="dt-pi">PIs</termref></strong>
 and <strong><termref def="dt-parentchild">child elements</termref></strong>
whose types have been declared.<br><br><a href="#dt-repltext">dt-repltext<br></a>The <strong><termref def="dt-repltext">replacement text</termref></strong> of any entity
referred to directly or indirectly in an attribute value MUST NOT contain a &lt;.<br><br><a href="#dt-interop">dt-interop<br></a>Empty-element tags may be used for any element which has no content, whether
or not it is declared using the keyword EMPTY. <strong><termref def="dt-interop">For
interoperability</termref></strong>, the empty-element tag SHOULD
be used, and SHOULD only be used, for elements which are declared
EMPTY.<br><br><a href="#dt-element">dt-element<br></a>The <strong><termref def="dt-element">element</termref></strong> structure of an <strong><termref def="dt-xml-doc">XML document</termref></strong> may, for <strong><termref def="dt-valid">validation</termref></strong>
purposes, be constrained using element type and attribute-list declarations.
An element type declaration constrains the element's <strong><termref def="dt-content">content</termref></strong>.<br><br><a href="#dt-parentchild">dt-parentchild<br></a>Element type declarations often constrain which element types can appear
as <strong><termref def="dt-parentchild">children</termref></strong> of the element. At user
option, an XML processor MAY issue a warning when a declaration mentions an
element type for which no declaration is provided, but this is not an error.<br><br><a href="#dt-parentchild">dt-parentchild<br></a>where each Name is the type of an element which
may appear as a <strong><termref def="dt-parentchild">child</termref></strong>. Any content
particle in a choice list may appear in the <strong><termref def="dt-elemcontent">element
content</termref></strong> at the location where the choice list appears in the grammar;
content particles occurring in a sequence list MUST each appear in the <strong><termref def="dt-elemcontent">element content</termref></strong> in the order given in the list.
The optional character following a name or list governs whether the element
or the content particles in the list may occur one or more (+),
zero or more (*), or zero or one times (?). The
absence of such an operator means that the element or content particle MUST
appear exactly once. This syntax and meaning are identical to those used in
the productions in this specification.<br><br><a href="#dt-compat">dt-compat<br></a>The content of an element matches a content model if and only if it is
possible to trace out a path through the content model, obeying the sequence,
choice, and repetition operators and matching each element in the content
against an element type in the content model. <strong><termref def="dt-compat">For
compatibility</termref></strong>, it is an error if the content model
allows an element to match more than one occurrence of an element type in the
content model. For more information, see .<br><br><a href="#dt-repltext">dt-repltext<br></a>Parameter-entity <strong><termref def="dt-repltext">replacement text</termref></strong>
							MUST be properly nested with parenthesized
groups. That is to say, if either of the opening or closing parentheses in
a choice, seq, or Mixed
construct is contained in the replacement text for a <strong><termref def="dt-PERef">parameter
entity</termref></strong>, both MUST be contained in the same replacement text.<br><br><a href="#dt-interop">dt-interop<br></a>
							<strong><termref def="dt-interop">For interoperability</termref></strong>, if a parameter-entity reference
appears in a choice, seq, or Mixed construct, its replacement text SHOULD contain at
least one non-blank character, and neither the first nor last non-blank character
of the replacement text SHOULD be a connector (| or ,).<br><br><a href="#dt-attr">dt-attr<br></a>
					<strong><termref def="dt-attr">Attributes</termref></strong> are used to associate name-value
pairs with <strong><termref def="dt-element">elements</termref></strong>. Attribute specifications
MUST NOT appear outside of <strong><termref def="dt-stag">start-tags</termref></strong> and <strong><termref def="dt-eetag">empty-element tags</termref></strong>; thus, the productions used to
recognize them appear in . Attribute-list declarations
may be used:<br><br><a href="#dt-default">dt-default<br></a>To provide <strong><termref def="dt-default">default values</termref></strong> for
attributes.<br><br><a href="#dt-interop">dt-interop<br></a>When more than one AttlistDecl is provided
for a given element type, the contents of all those provided are merged. When
more than one definition is provided for the same attribute of a given element
type, the first declaration is binding and later declarations are ignored. <strong><termref def="dt-interop">For interoperability,</termref></strong> writers of DTDs may choose
to provide at most one attribute-list declaration for a given element type,
at most one attribute definition for a given attribute name in an attribute-list
declaration, and at least one attribute definition in each attribute-list
declaration. For interoperability, an XML processor MAY at user option
issue a warning when more than one attribute-list declaration is provided
for a given element type, or more than one attribute definition is provided
for a given attribute, but this is not an error.<br><br><a href="#dt-unparsed">dt-unparsed<br></a>Values of type ENTITY
							MUST match the Name production, values of type ENTITIES
							MUST match Names; each Name
							MUST match the name of an <strong><termref def="dt-unparsed">unparsed entity</termref></strong>
declared in the <strong><termref def="dt-doctype">DTD</termref></strong>.<br><br><a href="#dt-notation">dt-notation<br></a>A NOTATION attribute identifies a <strong><termref def="dt-notation">notation</termref></strong>,
declared in the DTD with associated system and/or public identifiers, to be
used in interpreting the element to which the attribute is attached.<br><br><a href="#dt-compat">dt-compat<br></a>
							<strong><termref def="dt-compat">For compatibility</termref></strong>,
an attribute of type NOTATION
							MUST NOT be declared on an element
declared EMPTY.<br><br><a href="#dt-interop">dt-interop<br></a>
						<strong><termref def="dt-interop">For interoperability,</termref></strong> the same Nmtoken
						SHOULD NOT occur more than once in the enumerated
attribute types of a single element type.<br><br><a href="#dt-attdecl">dt-attdecl<br></a>An <strong><termref def="dt-attdecl">attribute declaration</termref></strong> provides information
on whether the attribute's presence is REQUIRED, and if not, how an XML processor
is to react if a declared attribute is absent in a document.<br><br><a href="#dt-attrval">dt-attrval<br></a>It is an error if an <strong><termref def="dt-attrval">attribute
value</termref></strong> contains a <strong><termref def="dt-entref">reference</termref></strong> to an
entity for which no declaration has been read.<br><br><a href="#dt-docent">dt-docent<br></a>
				An XML document may consist of one
or many storage units. These
are called entities; they all have content and are
all (except for the <strong><termref def="dt-docent">document entity</termref></strong> and
the <strong><termref def="dt-doctype">external DTD subset</termref></strong>) identified by
entity name. Each XML document has one entity
called the <strong><termref def="dt-docent">document entity</termref></strong>, which serves
as the starting point for the <strong><termref def="dt-xml-proc">XML processor</termref></strong>
and may contain the whole document.<br><br><a href="#dt-match">dt-match<br></a>In a document
without any DTD, a document with only an internal DTD subset which contains
no parameter entity references, or a document with 
							standalone='yes'
						, for
an entity reference that does not occur within the external subset or a parameter
entity, the Name given in the entity reference MUST
						<strong><termref def="dt-match">match</termref></strong> that in an entity
declaration that does not occur within the external subset or a
parameter entity, except that well-formed documents need not declare
any of the following entities: amp,
lt,
gt,
apos,
quot. The
declaration of a general entity MUST precede any reference to it which appears
in a default value in an attribute-list declaration.<br><br><a href="#dt-match">dt-match<br></a>In a document with an external subset or parameter  entity references,
						if the document is not standalone (either standalone='no'
						is specified or there is no standalone declaration), then
the Name given in the entity reference MUST
						<strong><termref def="dt-match">match</termref></strong> that in an entity
declaration. For interoperability, valid documents SHOULD declare
the entities amp,
lt,
gt,
apos,
quot, in the form specified in .
The declaration of a parameter entity MUST precede any reference to it. Similarly,
the declaration of a general entity MUST precede any attribute-list
declaration containing a default value with a direct or indirect reference
to that general entity.<br><br><a href="#dt-unparsed">dt-unparsed<br></a>An entity reference MUST
NOT contain the name of an <strong><termref def="dt-unparsed">unparsed entity</termref></strong>.
Unparsed entities may be referred to only in <strong><termref def="dt-attrval">attribute
values</termref></strong> declared to be of type ENTITY or ENTITIES.<br><br><a href="#dt-doctype">dt-doctype<br></a>Parameter-entity references MUST NOT appear outside
 the <strong><termref def="dt-doctype">DTD</termref></strong>.<br><br><a href="#dt-entref">dt-entref<br></a>The Name identifies the entity in an <strong><termref def="dt-entref">entity
reference</termref></strong> or, in the case of an unparsed entity, in the value of
an ENTITY or ENTITIES attribute. If the same entity is declared
more than once, the first declaration encountered is binding; at user option,
an XML processor MAY issue a warning if entities are declared multiple times.<br><br><a href="#dt-litentval">dt-litentval<br></a>
						If the
entity definition is an EntityValue, the defined
entity is called an internal entity. There is no separate physical
storage object, and the content of the entity is given in the declaration.
Note that some processing of entity and character references in the <strong><termref def="dt-litentval">literal entity value</termref></strong> may be required to produce
the correct <strong><termref def="dt-repltext">replacement text</termref></strong>: see .<br><br><a href="#dt-parsedent">dt-parsedent<br></a>An internal entity is a <strong><termref def="dt-parsedent">parsed entity</termref></strong>.<br><br><a href="#dt-unparsed">dt-unparsed<br></a>If the NDataDecl is present, this is a general <strong><termref def="dt-unparsed">unparsed entity</termref></strong>; otherwise it is a parsed entity.<br><br><a href="#dt-notation">dt-notation<br></a>The Name
							MUST match the declared name of a <strong><termref def="dt-notation">notation</termref></strong>.<br><br><a href="#dt-docent">dt-docent<br></a>
						The SystemLiteral is called the entity's system
identifier. It is meant to be converted to a URI reference
(as defined in ),
as part of the
process of dereferencing it to obtain input for the XML processor to construct the
entity's replacement text. It is an error for a fragment identifier
(beginning with a # character) to be part of a system identifier.
Unless otherwise provided by information outside the scope of this specification
(e.g. a special XML element type defined by a particular DTD, or a processing
instruction defined by a particular application specification), relative URIs
are relative to the location of the resource within which the entity declaration
occurs. This is defined to
be the external entity containing the '&lt;' which starts the declaration, at the
point when it is parsed as a declaration.
A URI might thus be relative to the <strong><termref def="dt-docent">document
entity</termref></strong>, to the entity containing the <strong><termref def="dt-doctype">external
DTD subset</termref></strong>, or to some other <strong><termref def="dt-extent">external parameter
entity</termref></strong>. Attempts to
retrieve the resource identified by a URI may be redirected at the parser
level (for example, in an entity resolver) or below (at the protocol level,
for example, via an HTTP Location: header). In the absence of additional
information outside the scope of this specification within the resource,
the base URI of a resource is always the URI of the actual resource returned.
In other words, it is the URI of the resource retrieved after all redirection
has occurred.<br><br><a href="#dt-repltext">dt-repltext<br></a>The text declaration MUST be provided literally, not by reference
					to a parsed entity. The text declaration
					MUST NOT appear at any
					position other than the beginning of an external parsed entity. The text declaration
          in an external parsed entity is not considered part of its <strong><termref def="dt-repltext">replacement text</termref></strong>.<br><br><a href="#dt-stag">dt-stag<br></a>A consequence of well-formedness in general
entities is that the logical and physical
structures in an XML document are properly nested; no <strong><termref def="dt-stag">start-tag</termref></strong>, <strong><termref def="dt-etag">end-tag</termref></strong>, <strong><termref def="dt-empty">empty-element tag</termref></strong>, <strong><termref def="dt-element">element</termref></strong>, <strong><termref def="dt-comment">comment</termref></strong>, <strong><termref def="dt-pi">processing instruction</termref></strong>, <strong><termref def="dt-charref">character
reference</termref></strong>, or <strong><termref def="dt-entref">entity reference</termref></strong>
can begin in one entity and end in another.<br><br><a href="#dt-docent">dt-docent<br></a>In the <strong><termref def="dt-docent">document entity</termref></strong>, the encoding
declaration is part of the <strong><termref def="dt-xmldecl">XML declaration</termref></strong>.
The EncName is the name of the encoding used.<br><br><a href="#dt-fatal">dt-fatal<br></a>In the absence of information provided by an external transport protocol
(e.g. HTTP or MIME), it is a <strong><termref def="dt-fatal">fatal error</termref></strong> for
an entity including an encoding declaration to be presented to the XML processor
in an encoding other than that named in the declaration, or for an entity which
begins with neither a Byte Order Mark
nor an encoding declaration to use an encoding other than UTF-8. Note that
since ASCII is a subset of UTF-8, ordinary ASCII entities do not strictly
need an encoding declaration.<br><br><a href="#dt-fatal">dt-fatal<br></a>It is a <strong><termref def="dt-fatal">fatal error</termref></strong> for a TextDecl to occur other
than at the beginning of an external entity.<br><br><a href="#dt-fatal">dt-fatal<br></a>It is a <strong><termref def="dt-fatal">fatal error</termref></strong> when an XML processor
encounters an entity with an encoding that it is unable to process. It
is a <strong><termref def="dt-fatal">fatal error</termref></strong> if an XML entity is determined (via default, encoding declaration,
or higher-level protocol) to be in a certain encoding but contains byte
sequences that are not legal in that encoding. Specifically, it is a
fatal error if an entity encoded in UTF-8 contains any irregularill-formed code unit sequences,
as defined in section 3.9 of  Unicode 3.1 . Unless an encoding
is determined by a higher-level protocol, it is also a <strong><termref def="dt-fatal">fatal error</termref></strong> if an XML entity
contains no encoding declaration and its content is not legal UTF-8 or UTF-16.<br><br><a href="#dt-xml-proc">dt-xml-proc<br></a>The table below summarizes the contexts in which character references,
entity references, and invocations of unparsed entities might appear and the
REQUIRED behavior of an <strong><termref def="dt-xml-proc">XML processor</termref></strong>
in each case. The labels in the leftmost column describe the recognition context: 
						
							Reference in Content
							
								as a reference anywhere after the <strong><termref def="dt-stag">start-tag</termref></strong>
and before the <strong><termref def="dt-etag">end-tag</termref></strong> of an element; corresponds
to the nonterminal content.
							
						
						
							Reference in Attribute Value
							
								as a reference within either the value of an attribute in a <strong><termref def="dt-stag">start-tag</termref></strong>,
or a default value in an <strong><termref def="dt-attdecl">attribute declaration</termref></strong>;
corresponds to the nonterminal AttValue.
							
						
						
							Occurs as Attribute Value
							
								as a Name, not a reference, appearing either as
the value of an attribute which has been declared as type ENTITY,
or as one of the space-separated tokens in the value of an attribute which
has been declared as type ENTITIES.
							
						
						
							Reference in Entity Value
							
								as a reference within a parameter or internal entity's <strong><termref def="dt-litentval">literal
entity value</termref></strong> in the entity's declaration; corresponds to the nonterminal EntityValue.
							
						
						
							Reference in DTD
							
								as a reference within either the internal or external subsets of the <strong><termref def="dt-doctype">DTD</termref></strong>, but outside of an EntityValue, AttValue, PI, Comment, SystemLiteral, PubidLiteral,
or the contents of an ignored conditional section (see ).
								.
							
						
					
				<br><br><a href="#dt-stag">dt-stag<br></a>as a reference anywhere after the <strong><termref def="dt-stag">start-tag</termref></strong>
and before the <strong><termref def="dt-etag">end-tag</termref></strong> of an element; corresponds
to the nonterminal content.<br><br><a href="#dt-stag">dt-stag<br></a>as a reference within either the value of an attribute in a <strong><termref def="dt-stag">start-tag</termref></strong>,
or a default value in an <strong><termref def="dt-attdecl">attribute declaration</termref></strong>;
corresponds to the nonterminal AttValue.<br><br><a href="#dt-litentval">dt-litentval<br></a>as a reference within a parameter or internal entity's <strong><termref def="dt-litentval">literal
entity value</termref></strong> in the entity's declaration; corresponds to the nonterminal EntityValue.<br><br><a href="#dt-doctype">dt-doctype<br></a>as a reference within either the internal or external subsets of the <strong><termref def="dt-doctype">DTD</termref></strong>, but outside of an EntityValue, AttValue, PI, Comment, SystemLiteral, PubidLiteral,
or the contents of an ignored conditional section (see ).<br><br><a href="#dt-chardata">dt-chardata<br></a>
						An entity is included
when its <strong><termref def="dt-repltext">replacement text</termref></strong> is retrieved
and processed, in place of the reference itself, as though it were part of
the document at the location the reference was recognized. The replacement
text may contain both <strong><termref def="dt-chardata">character data</termref></strong>
and (except for parameter entities) <strong><termref def="dt-markup">markup</termref></strong>,
which MUST be recognized in the usual way. (The string 
							AT&amp;amp;T;
						
expands to 
							AT&amp;T;
						 and the remaining ampersand
is not recognized as an entity-reference delimiter.) A character reference
is included when the indicated character is processed in place
of the reference itself. <br><br><a href="#dt-valid">dt-valid<br></a>When an XML processor recognizes a reference to a parsed entity, in order
to <strong><termref def="dt-valid">validate</termref></strong> the document, the processor
MUST
						<strong><termref def="dt-include">include</termref></strong> its replacement text. If
the entity is external, and the processor is not attempting to validate the
XML document, the processor MAY, but need
not, include the entity's replacement text. If a non-validating processor
does not include the replacement text, it MUST inform the application that
it recognized, but did not read, the entity.<br><br><a href="#dt-fatal">dt-fatal<br></a>The following are forbidden, and constitute <strong><termref def="dt-fatal">fatal
errors</termref></strong>:<br><br><a href="#dt-unparsed">dt-unparsed<br></a>the appearance of a reference to an <strong><termref def="dt-unparsed">unparsed
entity</termref></strong>, except in the
EntityValue in an entity declaration.<br><br><a href="#dt-entref">dt-entref<br></a>When an <strong><termref def="dt-entref">entity reference</termref></strong> appears in
an attribute value, or a parameter entity reference appears in a literal entity
value, its <strong><termref def="dt-repltext">replacement text</termref></strong>
						MUST be processed
in place of the reference itself as though it were part of the document at
the location the reference was recognized, except that a single or double
quote character in the replacement text MUST always be treated as a normal data
character and MUST NOT terminate the literal. For example, this is well-formed:<br><br><a href="#dt-unparsed">dt-unparsed<br></a>When the name of an <strong><termref def="dt-unparsed">unparsed entity</termref></strong>
appears as a token in the value of an attribute of declared type ENTITY
or ENTITIES, a validating processor MUST inform the application of
the <strong><termref def="dt-sysid">system</termref></strong> and <strong><termref def="dt-pubid">public</termref></strong>
(if any) identifiers for both the entity and its associated <strong><termref def="dt-notation">notation</termref></strong>.<br><br><a href="#dt-repltext">dt-repltext<br></a>Just as with external parsed entities, parameter entities need only be included if validating. When a parameter-entity
reference is recognized in the DTD and included, its <strong><termref def="dt-repltext">replacement
text</termref></strong>
						MUST be enlarged by the attachment of one leading and one following
space (#x20) character; the intent is to constrain the replacement text of
parameter entities to contain an integral number of grammatical tokens in
the DTD. This
behavior MUST NOT apply to parameter entity references within entity values;
these are described in .<br><br><a href="#dt-error">dt-error<br></a>It is an <strong><termref def="dt-error">error</termref></strong> for a reference to
		an unparsed entity to appear in the EntityValue in an
		entity declaration.<br><br><a href="#dt-include">dt-include<br></a>The literal entity value as given in an internal entity declaration (EntityValue) may contain character, parameter-entity,
and general-entity references. Such references MUST be contained entirely
within the literal entity value. The actual replacement text that is <strong><termref def="dt-include">included</termref></strong> (or <strong><termref def="inliteral">included in literal</termref></strong>) as described above
MUST contain the replacement
text of any parameter entities referred to, and MUST contain the character
referred to, in place of any character references in the literal entity value;
however, general-entity references MUST be left as-is, unexpanded. For example,
given the following declarations:<br><br><a href="#dt-interop">dt-interop<br></a>All XML processors MUST recognize these entities whether they are declared
or not. <strong><termref def="dt-interop">For interoperability</termref></strong>, valid XML
documents SHOULD declare these entities, like any others, before using them. If
the entities lt or amp are declared, they MUST be
declared as internal entities whose replacement text is a character reference
to the respective
character (less-than sign or ampersand) being escaped; the double
escaping is REQUIRED for these entities so that references to them produce
a well-formed result. If the entities gt, apos,
or quot are declared, they MUST be declared as internal entities
whose replacement text is the single character being escaped (or a character
reference to that character; the double escaping here is OPTIONAL but harmless).
For example:<br><br><a href="#dt-sysid">dt-sysid<br></a>XML processors MUST provide applications with the name and external identifier(s)
of any notation declared and referred to in an attribute value, attribute
definition, or entity declaration. They MAY additionally resolve the external
identifier into the <strong><termref def="dt-sysid">system identifier</termref></strong>, file
name, or other information needed to allow the application to call a processor
for data in the notation described. (It is not an error, however, for XML
documents to declare and refer to notations for which notation-specific applications
are not available on the system where the XML processor or application is
running.)<br><br><a href="#dt-xml-proc">dt-xml-proc<br></a>Conforming <strong><termref def="dt-xml-proc">XML processors</termref></strong> fall into
two classes: validating and non-validating.<br><br><a href="#dt-docent">dt-docent<br></a>Validating and non-validating processors alike MUST report violations of
this specification's well-formedness constraints in the content of the <strong><termref def="dt-docent">document entity</termref></strong> and any other <strong><termref def="dt-parsedent">parsed
entities</termref></strong> that they read.<br><br><a href="#dt-docent">dt-docent<br></a>Non-validating processors are REQUIRED to check only the <strong><termref def="dt-docent">document
entity</termref></strong>, including the entire internal DTD subset, for well-formedness.  While they are not required
to check the document for validity, they are REQUIRED to process
all the declarations they read in the internal DTD subset and in any parameter
entity that they read, up to the first reference to a parameter entity that
they do not read; that is to say, they MUST use the information
in those declarations to normalize
attribute values, include the replacement
text of internal entities, and supply default
attribute values. Except when standalone="yes", they
MUST NOT
					<strong><termref def="dt-use-mdecl">process</termref></strong>
					<strong><termref def="dt-entdecl">entity
declarations</termref></strong> or <strong><termref def="dt-attdecl">attribute-list declarations</termref></strong>
encountered after a reference to a parameter entity that is not read, since
the entity may have contained overriding declarations; when standalone="yes", processors MUST
process these declarations.<br><br><a href="#dt-match">dt-match<br></a>matches a literal string <strong><termref def="dt-match">matching</termref></strong> that
given inside the double quotes.<br><br><a href="#dt-match">dt-match<br></a>matches a literal string <strong><termref def="dt-match">matching</termref></strong> that
given inside the single quotes.<br><br><a href="#dt-wellformed">dt-wellformed<br></a>well-formedness constraint; this identifies by name a constraint on <strong><termref def="dt-wellformed">well-formed</termref></strong> documents associated with a production.<br><br><a href="#dt-valid">dt-valid<br></a>validity constraint; this identifies by name a constraint on <strong><termref def="dt-valid">valid</termref></strong>
documents associated with a production.<br><br><a href="#dt-compat">dt-compat<br></a>As
noted in , it is required that content
models in element type declarations be deterministic. This requirement is <strong><termref def="dt-compat">for compatibility</termref></strong> with SGML (which calls deterministic
content models unambiguous); XML processors built
using SGML systems may flag non-deterministic content models as errors.<br><br>
</BODY>
</HTML>
