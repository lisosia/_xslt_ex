<HTML><BODY>
<h1>Term Definitions</h1>
<table border="1">
<tr>
<th>word</th>
<th>definition</th>
</tr>
<tr>
<td>XML Processor</td>
<td>A software module called
an XML processor is used to read XML documents and provide access
to their content and structure.</td>
</tr>
<tr>
<td>Application</td>
<td>It
is assumed that an XML processor is doing its work on behalf of another module,
called the application.</td>
</tr>
<tr>
<td>Error</td>
<td>A violation of the rules of this specification;
results are undefined. Unless otherwise specified, failure to observe a prescription of this specification indicated by one of the keywords MUST, REQUIRED, MUST NOT, SHALL and SHALL NOT is an error.  Conforming software MAY detect and report an error
and MAY recover from it.</td>
</tr>
<tr>
<td>Fatal Error</td>
<td>An error which a conforming XML processor
										MUST detect and report to the application.
After encountering a fatal error, the processor MAY continue processing the
data to search for further errors and MAY report such errors to the application.
In order to support correction of errors, the processor MAY make unprocessed
data from the document (with intermingled character data and markup) available
to the application. Once a fatal error is detected, however, the processor
MUST NOT continue normal processing (i.e., it MUST NOT continue to pass character
data and information about the document's logical structure to the application
in the normal way).</td>
</tr>
<tr>
<td>At user option</td>
<td>Conforming software
MAY or MUST (depending on the modal verb in the sentence) behave as described;
if it does, it MUST provide users a means to enable or disable the behavior
described.</td>
</tr>
<tr>
<td>Validity constraint</td>
<td>A rule which applies to
all valid XML documents. Violations of validity
constraints are errors; they MUST, at user option, be reported by validating XML processors.</td>
</tr>
<tr>
<td>Well-formedness constraint</td>
<td>A rule which applies
to all well-formed XML documents. Violations
of well-formedness constraints are fatal errors.</td>
</tr>
<tr>
<td>match</td>
<td>(Of strings or names:) Two strings
or names being compared are identical. Characters with multiple possible
representations in ISO/IEC 10646 (e.g. characters with both precomposed and
base+diacritic forms) match only if they have the same representation in both
strings. No
case folding is performed. (Of strings and rules in the grammar:) A string
matches a grammatical production if it belongs to the language generated by
that production. (Of content and content models:) An element matches its declaration
when it conforms in the fashion described in the constraint .</td>
</tr>
<tr>
<td>For Compatibility</td>
<td>Marks
a sentence describing a feature of XML included solely to ensure
that XML remains compatible with SGML.</td>
</tr>
<tr>
<td>For interoperability</td>
<td>Marks
a sentence describing a non-binding recommendation included to increase
the chances that XML documents can be processed by the existing installed
base of SGML processors which predate the WebSGML Adaptations Annex to ISO 8879.</td>
</tr>
<tr>
<td>XML Document</td>
<td> A data object is an XML
document if it is well-formed,
as defined in this specification. In addition, the XML document is
valid if it meets certain further constraints.</td>
</tr>
<tr>
<td>Well-Formed</td>
<td> A textual object is a well-formed
XML document if:</td>
</tr>
<tr>
<td>Root Element</td>
<td>There is exactly one element,
called the root, or document element, no part of which appears
in the content of any other element.</td>
</tr>
<tr>
<td>Parent/Child</td>
<td>As a consequence of this,
for each non-root element C in the document, there is one other element P
in the document such that C is in the content of P, but
is not in the content of any other element that is in the content of P. P
is referred to as the parent of C, and C as
a child of P.</td>
</tr>
<tr>
<td>Text</td>
<td>A parsed entity contains text,
a sequence of characters, which may
represent markup or character data.</td>
</tr>
<tr>
<td>Character</td>
<td>A character
is an atomic unit of text as specified by ISO/IEC 10646:2000 . Legal characters are tab, carriage
return, line feed, and the legal characters
of Unicode and ISO/IEC 10646. The
versions of these standards cited in  were
current at the time this document was prepared. New characters may be added
to these standards by amendments or new editions. Consequently, XML processors
MUST accept any character in the range specified for Char.
</td>
</tr>
<tr>
<td>Name</td>
<td>A Name is a token beginning
with a letter or one of a few punctuation characters, and continuing with
letters, digits, hyphens, underscores, colons, or full stops, together known
as name characters.</td>
</tr>
<tr>
<td>Name</td>
<td>A Name is an Nmtoken with a restricted set of initial characters.</td>
</tr>
<tr>
<td>Markup</td>
<td>
						Markup takes the form of start-tags, end-tags, empty-element tags, entity references, character
references, comments, CDATA section delimiters, document
type declarations, processing instructions, XML declarations, text declarations,
and any white space that is at the top level of the document entity (that
is, outside the document element and not inside any other markup).</td>
</tr>
<tr>
<td>Character Data</td>
<td>All text that is not markup
constitutes the character data of the document.</td>
</tr>
<tr>
<td>Comment</td>
<td>
						Comments may appear
anywhere in a document outside other markup;
in addition, they may appear within the document type declaration at places
allowed by the grammar. They are not part of the document's character
data; an XML processor MAY, but need not, make it possible for an
application to retrieve the text of comments. For
compatibility, the string 
							--
						 (double-hyphen)
MUST NOT occur within comments.</td>
</tr>
<tr>
<td>Processing instruction</td>
<td>
						Processing instructions
(PIs) allow documents to contain instructions for applications.</td>
</tr>
<tr>
<td>CDATA Section</td>
<td>
						CDATA sections may occur anywhere character data may occur; they are used to escape blocks
of text containing characters which would otherwise be recognized as markup.
CDATA sections begin with the string 
							&lt;![CDATA[
						
and end with the string 
							]]&gt;
						:</td>
</tr>
<tr>
<td>XML Declaration</td>
<td>XML documents SHOULD
begin with an XML declaration which specifies the version of
XML being used.</td>
</tr>
<tr>
<td>Validity</td>
<td>An XML document is valid if it has an associated
document type declaration and if the document complies with the constraints
expressed in it.</td>
</tr>
<tr>
<td>Document Type Declaration</td>
<td>The XML document
type declaration contains or points to markup
declarations that provide a grammar for a class of documents. This
grammar is known as a document type definition, or DTD. The document
type declaration can point to an external subset (a special kind of external entity) containing markup declarations,
or can contain the markup declarations directly in an internal subset, or
can do both. The DTD for a document consists of both subsets taken together.</td>
</tr>
<tr>
<td>markup declaration</td>
<td> A markup declaration
is an element type declaration, an attribute-list declaration, an entity
declaration, or a notation declaration.</td>
</tr>
<tr>
<td>External Markup Declaration</td>
<td>An external
markup declaration is defined as a markup declaration occurring in
the external subset or in a parameter entity (external or internal, the latter
being included because non-validating processors are not required to read
them).</td>
</tr>
<tr>
<td>Element</td>
<td>Each XML
document contains one or more elements, the boundaries
of which are either delimited by start-tags
and end-tags, or, for empty
elements, by an empty-element tag. Each
element has a type, identified by name, sometimes called its generic
identifier (GI), and may have a set of attribute specifications.</td>
</tr>
<tr>
<td>Start-Tag</td>
<td>The beginning of every non-empty
XML element is marked by a start-tag.</td>
</tr>
<tr>
<td>Attribute</td>
<td> The Name-AttValue
pairs are referred to as the attribute specifications of the
element</td>
</tr>
<tr>
<td>Attribute Name</td>
<td>with the Name in each pair referred to as the attribute name
					</td>
</tr>
<tr>
<td>Attribute Value</td>
<td>the content of the AttValue (the text between the ' or "
delimiters) as the attribute value.</td>
</tr>
<tr>
<td>End Tag</td>
<td>The end of every element that begins
with a start-tag MUST be marked by an end-tag containing a name
that echoes the element's type as given in the start-tag:</td>
</tr>
<tr>
<td>Content</td>
<td>The text
between the start-tag and end-tag is called the element's content:</td>
</tr>
<tr>
<td>Empty</td>
<td>An element
with no content is said to be empty.</td>
</tr>
<tr>
<td>empty-element tag</td>
<td>An empty-element
tag takes a special form:</td>
</tr>
<tr>
<td>Element Type declaration</td>
<td>An element
type declaration takes the form:</td>
</tr>
<tr>
<td>Element content</td>
<td>An element type has element content when elements
of that type MUST contain only child
elements (no character data), optionally separated by white space (characters
matching the nonterminal S).</td>
</tr>
<tr>
<td>Content model</td>
<td>In this case, the constraint includes a content
model, a simple grammar governing the allowed types of the
child elements and the order in which they are allowed to appear.</td>
</tr>
<tr>
<td>Mixed Content</td>
<td>An element type
has mixed content when elements of that type may contain character
data, optionally interspersed with child
elements.</td>
</tr>
<tr>
<td>Attribute-List Declaration</td>
<td>
						Attribute-list
declarations specify the name, data type, and default value (if any)
of each attribute associated with a given element type:</td>
</tr>
<tr>
<td>Enumerated Attribute Values</td>
<td>
							Enumerated attributes
							have a list of allowed values in their declaration
						</td>
</tr>
<tr>
<td>Attribute Default</td>
<td>If
the declaration is neither #REQUIRED nor #IMPLIED, then
the AttValue value contains the declared default
value; the #FIXED keyword states that the attribute MUST always have
the default value.
When an XML processor encounters
an element
without a specification for an attribute for which it has read a default
value declaration, it MUST report the attribute with the declared default
value to the application.</td>
</tr>
<tr>
<td>conditional section</td>
<td>
						Conditional
sections are portions of the document type
declaration external subset or
of external parameter entities which are included in, or excluded from,
the logical structure of the DTD based on the keyword which governs them.</td>
</tr>
<tr>
<td>Entity</td>
<td>An XML document may consist of one
or many storage units. These
are called entities; they all have content and are
all (except for the document entity and
the external DTD subset) identified by
entity name.</td>
</tr>
<tr>
<td>Text Entity</td>
<td>The contents of a parsed
entity are referred to as its replacement
text; this text is considered an
integral part of the document.</td>
</tr>
<tr>
<td>Unparsed Entity</td>
<td>An unparsed entity
is a resource whose contents may or may not be text,
and if text, may
be other than XML. Each unparsed entity has an associated notation, identified by name. Beyond a requirement
that an XML processor make the identifiers for the entity and notation available
to the application, XML places no constraints on the contents of unparsed
entities.</td>
</tr>
<tr>
<td>general entity</td>
<td>
					General entities
are entities for use within the document content. In this specification, general
entities are sometimes referred to with the unqualified term entity
when this leads to no ambiguity.</td>
</tr>
<tr>
<td>Parameter entity</td>
<td>
					Parameter
entities are parsed entities for use within the DTD.</td>
</tr>
<tr>
<td>Character Reference</td>
<td> A character
reference refers to a specific character in the ISO/IEC 10646 character
set, for example one not directly accessible from available input devices.</td>
</tr>
<tr>
<td>Entity Reference</td>
<td>An entity reference
refers to the content of a named entity.</td>
</tr>
<tr>
<td>General Entity Reference</td>
<td>References to parsed general entities use
ampersand (&amp;) and semicolon (;) as delimiters.</td>
</tr>
<tr>
<td>Parameter-entity reference</td>
<td>
						Parameter-entity references
use percent-sign (%) and semicolon (;) as delimiters.</td>
</tr>
<tr>
<td>entity declaration</td>
<td> Entities are declared
thus:</td>
</tr>
<tr>
<td>Internal Entity Replacement Text</td>
<td>If the
entity definition is an EntityValue, the defined
entity is called an internal entity. There is no separate physical
storage object, and the content of the entity is given in the declaration.</td>
</tr>
<tr>
<td>External Entity</td>
<td>If the entity is not internal,
it is an external entity, declared as follows:</td>
</tr>
<tr>
<td>System Identifier</td>
<td>The SystemLiteral is called the entity's system
identifier. It is meant to be converted to a URI reference
(as defined in ),
as part of the
process of dereferencing it to obtain input for the XML processor to construct the
entity's replacement text.</td>
</tr>
<tr>
<td>Public identifier</td>
<td> In addition to a system
identifier, an external identifier may include a public identifier.</td>
</tr>
<tr>
<td>Include</td>
<td>An entity is included
when its replacement text is retrieved
and processed, in place of the reference itself, as though it were part of
the document at the location the reference was recognized.</td>
</tr>
<tr>
<td>Literal Entity Value</td>
<td>For an
internal entity, the literal
entity value is the quoted string actually present in the entity declaration,
corresponding to the non-terminal EntityValue.</td>
</tr>
<tr>
<td>Literal Entity Value</td>
<td>For an external entity, the literal
entity value is the exact text contained in the entity.</td>
</tr>
<tr>
<td>Replacement Text</td>
<td>For an
internal entity, the replacement text
is the content of the entity, after replacement of character references and
parameter-entity references.</td>
</tr>
<tr>
<td>Replacement Text</td>
<td>For
an external entity, the replacement text is the content of the entity,
after stripping the text declaration (leaving any surrounding whitespace) if there
is one but without any replacement of character references or parameter-entity
references.</td>
</tr>
<tr>
<td>escape</td>
<td>Entity and character references may
both be used to escape the left angle bracket, ampersand, and
other delimiters. A set of general entities (amp,
lt,
gt,
apos,
quot) is specified for
this purpose. Numeric character references may also be used; they are expanded
immediately when recognized and MUST be treated as character data, so the
numeric character references 
							&amp;#60;
						 and 
							&amp;#38;
						 may be used to escape &lt; and &amp; when they occur
in character data.</td>
</tr>
<tr>
<td>Notation</td>
<td>
						Notations identify
by name the format of unparsed entities,
the format of elements which bear a notation attribute, or the application
to which a processing instruction is addressed.</td>
</tr>
<tr>
<td>Notation Declaration</td>
<td>
						Notation declarations
provide a name for the notation, for use in entity and attribute-list declarations
and in attribute specifications, and an external identifier for the notation
which may allow an XML processor or its client application to locate a helper
application capable of processing data in the given notation.</td>
</tr>
<tr>
<td>Document Entity</td>
<td>The document entity
serves as the root of the entity tree and a starting-point for an XML processor.</td>
</tr>
<tr>
<td>Validating Processor</td>
<td>
						Validating
processors
						MUST,
at user option, report violations of the constraints expressed by
the declarations in the DTD, and failures
to fulfill the validity constraints given in this specification.</td>
</tr>
<tr>
<td>Process Declarations</td>
<td> While they are not required
to check the document for validity, they are REQUIRED to process
all the declarations they read in the internal DTD subset and in any parameter
entity that they read, up to the first reference to a parameter entity that
they do not read; that is to say, they MUST use the information
in those declarations to normalize
attribute values, include the replacement
text of internal entities, and supply default
attribute values.</td>
</tr>
</table>
<h1>Definitions(described in paragraph) ,vcnote</h1>
<table border="1">
<tr>
<th>word</th>
<th>definition</th>
</tr>
<tr>
<td>Root Element Type</td>
<td>The Name
in the document type declaration MUST match the element type of the root element.</td>
</tr>
<tr>
<td>Proper Declaration/PE Nesting</td>
<td>Parameter-entity replacement text
						MUST be properly nested with markup declarations. That is to say, if either
the first character or the last character of a markup declaration (markupdecl
above) is contained in the replacement text for a parameter-entity
reference, both MUST be contained in the same replacement text.</td>
</tr>
<tr>
<td>Standalone Document Declaration</td>
<td>The
standalone document declaration MUST have the value no if
any external markup declarations contain declarations of:</td>
</tr>
<tr>
<td>Element Valid</td>
<td>An element is valid
if there is a declaration matching elementdecl
where the Name matches the element type, and one of
the following holds:</td>
</tr>
<tr>
<td>Attribute Value Type</td>
<td>The attribute MUST
have been declared; the value MUST be of the type declared for it. (For attribute
types, see .)</td>
</tr>
<tr>
<td>Unique Element Type Declaration</td>
<td>An element type MUST NOT be declared more than once.</td>
</tr>
<tr>
<td>Proper Group/PE Nesting</td>
<td>Parameter-entity replacement text
							MUST be properly nested with parenthesized
groups. That is to say, if either of the opening or closing parentheses in
a choice, seq, or Mixed
construct is contained in the replacement text for a parameter
entity, both MUST be contained in the same replacement text.</td>
</tr>
<tr>
<td>No Duplicate Types</td>
<td>The
same name MUST NOT appear more than once in a single mixed-content declaration.</td>
</tr>
<tr>
<td>ID</td>
<td>Values of type ID
							MUST match the Name production. A name MUST NOT appear more than once
in an XML document as a value of this type; i.e., ID values MUST uniquely
identify the elements which bear them.</td>
</tr>
<tr>
<td>One ID per Element Type</td>
<td>An element type MUST NOT have more than one ID attribute specified.</td>
</tr>
<tr>
<td>ID Attribute Default</td>
<td>An ID attribute
MUST have a declared default of #IMPLIED or #REQUIRED.</td>
</tr>
<tr>
<td>IDREF</td>
<td>Values of type IDREF
							MUST
match the Name production, and values of type IDREFS
							MUST match Names; each Name
							MUST match the value of an ID attribute on some element in the XML document;
i.e. IDREF values MUST match the value of some ID attribute.</td>
</tr>
<tr>
<td>Entity Name</td>
<td>Values of type ENTITY
							MUST match the Name production, values of type ENTITIES
							MUST match Names; each Name
							MUST match the name of an unparsed entity
declared in the DTD.</td>
</tr>
<tr>
<td>Name Token</td>
<td>Values of type NMTOKEN
							MUST match the Nmtoken production; values of type NMTOKENS
							MUST match Nmtokens.</td>
</tr>
<tr>
<td>Notation Attributes</td>
<td>Values of this type
MUST match one of the notation names
included in the declaration; all notation names in the declaration MUST be
declared.</td>
</tr>
<tr>
<td>One Notation Per Element Type</td>
<td>An element type MUST NOT have more than one NOTATION
attribute specified.</td>
</tr>
<tr>
<td>No Notation on Empty Element</td>
<td>
							For compatibility,
an attribute of type NOTATION
							MUST NOT be declared on an element
declared EMPTY.</td>
</tr>
<tr>
<td>No Duplicate Tokens</td>
<td>The notation names in a single NotationType
attribute declaration, as well as the NmTokens in a single
Enumeration attribute declaration, MUST all be distinct.</td>
</tr>
<tr>
<td>Enumeration</td>
<td>Values of this type MUST match
one of the Nmtoken tokens in the declaration.</td>
</tr>
<tr>
<td>Required Attribute</td>
<td>If the default
declaration is the keyword #REQUIRED, then the attribute MUST be
specified for all elements of the type in the attribute-list declaration.</td>
</tr>
<tr>
<td>Attribute Default Value Syntactically Correct</td>
<td>The declared default value MUST meet the syntactic
constraints of the declared attribute type. That is, the default value of an attribute:
						</td>
</tr>
<tr>
<td>Fixed Attribute Default</td>
<td>If an attribute
has a default value declared with the #FIXED keyword, instances of
that attribute MUST match the default value.</td>
</tr>
<tr>
<td>Proper Conditional Section/PE Nesting</td>
<td>If any of the "&lt;![",
"[", or "]]&gt;" of a conditional section is contained
in the replacement text for a parameter-entity reference, all of them MUST
be contained in the same replacement text.</td>
</tr>
<tr>
<td>Entity Declared</td>
<td>In a document with an external subset or parameter  entity references,
						if the document is not standalone (either standalone='no'
						is specified or there is no standalone declaration), then
the Name given in the entity reference MUST
						match that in an entity
declaration. For interoperability, valid documents SHOULD declare
the entities amp,
lt,
gt,
apos,
quot, in the form specified in .
The declaration of a parameter entity MUST precede any reference to it. Similarly,
the declaration of a general entity MUST precede any attribute-list
declaration containing a default value with a direct or indirect reference
to that general entity.</td>
</tr>
<tr>
<td>Notation Declared</td>
<td>The Name
							MUST match the declared name of a notation.</td>
</tr>
<tr>
<td>Unique Notation Name</td>
<td>A given Name
						MUST NOT be declared in more than one notation declaration.</td>
</tr>
</table>
</BODY></HTML>
